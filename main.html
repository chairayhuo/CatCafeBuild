<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>cat cafe</title>
<script src="https://zimjs.org/cdn/1.3.4/createjs.js"></script>
<script src="https://zimjs.org/cdn/01/zim_min.js"></script>
<script type=module>
import zim from "https://zimjs.org/cdn/015/zim_game";
const assets = ["blackcat.png","tuxcat.png","orangecat.png","whitecat.png"]
const path = "assets/";
// See Docs under Frame for FIT, FILL, FULL, and TAG
new Frame(FIT, 1024, 768, light, dark, ready, assets, path);
function ready() {
    const background = new Pic ("catcafe.png").sca(1.5).center();

    const timer = new Timer({
        time:60,
        font:"BabyDoll.ttf",
        backgroundColor:orange,
        borderColor:dark,
    }).loc(100,100);

    let score = new Scorer({
        font:"BabyDoll.ttf",
        backgroundColor:orange,
        borderColor: black,
        borderWidth:3,
        width:60
    }).loc(W-100,100);

    let spotA = new Rectangle(150, 150, clear).loc(500,400).outline().reg(CENTER);
    let spotB = new Rectangle(150, 150, clear).loc(150,500).outline().reg(CENTER);
    let spotC = new Rectangle(150, 150, clear).loc(900,450).outline().reg(CENTER);
    let spotD = new Rectangle(150, 150, clear).loc(700,450).outline().reg(CENTER);
    

    let orangecat = new Pic ("orangecat.png").sca(0.5);
    let whitecat = new Pic ("whitecat.png").sca(0.5);
    let blackcat = new Pic ("blackcat.png").sca(0.5);
    let tuxcat = new Pic ("tuxcat.png").sca(0.5);

    let spots = [spotA, spotB, spotC, spotD];
    
    let initialItems = [
        ["milk", "brush", "food"],
        ["food", "milk", "catnip"],
        ["catnip", "milk", "toy"],
        ["brush", "catnip", "food"]
    ];

    let cats = [
        { cat: blackcat, satisfaction: 0, accepting: [...initialItems[0]], spot: null },
        { cat: orangecat, satisfaction: 0, accepting: [...initialItems[1]], spot: null },
        { cat: whitecat, satisfaction: 0, accepting: [...initialItems[2]], spot: null },
        { cat: tuxcat, satisfaction: 0, accepting: [...initialItems[3]], spot: null }
    ];
    function addRandomCat() {

        // After adding a cat, set a timeout to add another cat after a random delay
        let delay = Math.random() * 4000 + 1000; // Random delay between 1-5 seconds
        setTimeout(addRandomCat, delay);
    }

    // Start adding cats 2 seconds after the game starts
    setInterval(addRandomCat, 2000);

    function getRandomSpot() {
    let availableSpots = spots.filter(spot => !spot.occupied);
    if (availableSpots.length === 0) {
        return null; 
    }
        let randomIndex = Math.floor(Math.random() * availableSpots.length);
        return availableSpots[randomIndex];
    }

    function getRandomCat() {
        let randomIndex = Math.floor(Math.random() * cats.length);
        return cats[randomIndex];
    }
    function addRandomCat() {
    let randomSpot = getRandomSpot();
    if (!randomSpot) {
        return; // No available spot, so don't add a new cat
    }
    randomSpot.occupied = true;
    let randomCat = getRandomCat();
    randomCat.spot = randomSpot; 
    let spotCenterX = randomSpot.x + randomSpot.width / 2;
    let spotCenterY = randomSpot.y + randomSpot.height / 2;
    let catCenterX = spotCenterX - randomCat.cat.width / 2;
    let catCenterY = spotCenterY - randomCat.cat.height / 2;
    randomCat.cat.x = catCenterX;
    randomCat.cat.y = catCenterY;
    randomCat.cat.addTo();
    randomCat.cat.on("satisfied", () => {
        if (randomCat.satisfaction >= 3) {
            zog(`Removing ${randomCat.cat} because satisfaction is ${randomCat.satisfaction}`);
            randomCat.cat.removeFrom();
            randomSpot.occupied = false;
        }
    });
    }

    let milk;
    let food;
    let brush;
    let catnip
    let toy;

    const item1 = new Container(100, 100).loc(103, 578);
    const item2 = new Container(100, 100).loc(306, 608);
    const item3 = new Container(100, 100).loc(797, 624);
    const item4 = new Container(100, 100).loc(462, 606);
    const item5 = new Container(100, 100).loc(662, 602);

    loop(10, () => {
        milk = new Pic("milkdemo.png").addTo(item1).scaleTo(item1).drag();
        milk.name = "milk";
        food = new Pic("fooddemo.png").addTo(item2).scaleTo(item2).drag();
        food.name = "food";
        brush = new Pic("brushdemo.png").addTo(item3).scaleTo(item3).drag();
        brush.name = "brush";
        catnip = new Pic("catnipdemo.png").addTo(item4).scaleTo(item4).drag();
        catnip.name = "catnip";
        toy = new Pic("toydemo.png").addTo(item5).scaleTo(item5).drag();
        toy.name = "toy";

        [milk, food, brush,catnip,toy].forEach(item => {
            item.startScale = { scaleX: item.scaleX, scaleY: item.scaleY }; 
            item.startPos = { x: item.x, y: item.y }; 
            item.on("pressup", () => checkItem(item));
        });
    });


    function checkItem(item) {
    cats.forEach((catInfo, index) => {
        // Check if the cat's satisfaction has already reached 3
        if (catInfo.satisfaction === 3) {
            return; // Skip item interaction for this cat
        }

        if (item.hitTestBounds(catInfo.cat)) {
            if (item.name && typeof item.name === 'string' && catInfo.accepting.includes(item.name)) {
                // Remove the item from the accepting array
                catInfo.accepting = catInfo.accepting.filter(i => i !== item.name);

                // Increase satisfaction
                catInfo.satisfaction++;
                zog(`Increased satisfaction of ${catInfo.cat} to ${catInfo.satisfaction}`);

                // If the cat's satisfaction has reached 3, dispatch the 'satisfied' event
                if (catInfo.satisfaction === 3) {
                    catInfo.cat.dispatchEvent("satisfied");
                    catInfo.accepting = [...initialItems[index]];
                    animateCatOffScreen(catInfo.cat);
                    score.score++;
                    zog(score.score);
                }

                // Dispose of the item
                item.dispose();
            } else {
                // If the cat is not accepting the item, snap it back to the start position
                item.animate({ x: item.startPos.x, y: item.startPos.y }, 0.3);
            }
        } else {
            // If the item is not hitting any cat, snap it back to the start position
            item.animate({ x: item.startPos.x, y: item.startPos.y }, 0.3);
        }
    });
}

    // function checkItem(item) {
    //     cats.forEach((catInfo, index) => {
    //         if (item.hitTestBounds(catInfo.cat)) {
    //             if (item.name && typeof item.name === 'string' && catInfo.accepting.includes(item.name)) {
    //                 // Remove the item from the accepting array
    //                 catInfo.accepting = catInfo.accepting.filter(i => i !== item.name);

    //                 // Increase satisfaction
    //                 catInfo.satisfaction++;
    //                 zog(`Increased satisfaction of ${catInfo.cat} to ${catInfo.satisfaction}`);

    //                 // If the cat's satisfaction has reached 3, dispatch the 'satisfied' event
    //                 if (catInfo.satisfaction == 3) {
    //                     catInfo.cat.dispatchEvent("satisfied");
    //                     catInfo.accepting = [...initialItems[index]];
    //                     animateCatOffScreen(catInfo.cat);
    //                     score.score++;
    //                     zog(score.score);
    //                 }

    //                 // Dispose of the item
    //                 item.dispose();
    //             } else {
    //                 // If the cat is not accepting the item, snap it back to the start position
    //                 item.animate({ x: item.startPos.x, y: item.startPos.y }, 0.3);
    //             }
    //         } else {
    //             // If the item is not hitting any cat, snap it back to the start position
    //             item.animate({ x: item.startPos.x, y: item.startPos.y }, 0.3);
    //         }
    //     });
    // }

    function animateCatOffScreen(cat) {
        cat.animate([
            { props: { y: cat.y - 20 }, time: 0.5, ease: "bounceIn" },
            { props: { y: cat.y + 20 }, time: 0.7, ease: "bounceOut" },
            { props: { x: -500, y: 50 }, time: 5, ease: "backOut" }
        ], null, () => {
            // Animation completed, remove the cat
            cat.removeFrom();

            // Add a new cat after removing the current one
            addRandomCat();
        });

        // Listen for the end of the animation
        cat.on("animationend", () => {
            // Check if the cat still exists (it might have been removed manually)
            if (cat.stage) {
                cat.removeFrom(); // Remove the cat from the scene
                addRandomCat(); // Add a new cat
            }
        });
    }




//     items.forEach(function(item) {
//         let current;
//         item.on("mousedown", function(e) {
//             current = e.target;
//             current.copy = current.clone()
//                 .addTo()
//                 .drag();
//             current.top();
//             S.update();
//         });

//         item.on("pressup", function(e) {
//             current = e.currentTarget;

//             // Swap positions
//             swapProperties("x", current, current.copy);
//             swapProperties("y", current, current.copy);

//             // Check if the item was dropped on a matching cat
//             const status = loop(cats, function(cat, i) {
//                 if (cat.hitTestBounds(item)) { 
//                     if (item.text == cat.name) { 
//                         return "hitting"; 
//                     }
//                 }
//             });

//             if (status != "hitting") {
//                 current.copy.animate({alpha:0}, .2);
//                 current.animate({alpha:1}, .2);
//             }

//             S.update();
//         });
//     });

//     function swapProperties(prop, obj1, obj2) {
//     let temp = obj1[prop];
//     obj1[prop] = obj2[prop];
//     obj2[prop] = temp;
// }

// setInterval(() => {
//     cats.forEach(catInfo => {
//         catInfo.accepting = 3; 
//     });
// }, 5); 


        
} // end ready

</script>
<meta name="viewport" content="width=device-width, user-scalable=no" />
</head>
<body></body>
</html>